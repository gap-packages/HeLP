<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (HeLP) - Chapter 3: Further functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X85C2B0617ECCA64E" name="X85C2B0617ECCA64E"></a></p>
<div class="ChapSects"><a href="chap3.html#X85C2B0617ECCA64E">3 <span class="Heading">Further functions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X85F252368293DB34">3.1 <span class="Heading">Checks for specific orders</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F8F6E3D80A23C1D">3.1-1 HeLP_WithGivenOrder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CD0CEF283F13F7B">3.1-2 HeLP_WithGivenOrderAndPA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8186F17681AF25F5">3.1-3 HeLP_WithGivenOrderAllTables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81063633815E39CE">3.1-4 HeLP_WithGivenOrderAndPAAllTables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80D9773D86873CB2">3.1-5 HeLP_WithGivenOrderAndPAAndSpecificSystem</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7FCD80AC87DD0460">3.2 <span class="Heading">Checks for specific orders with s-constant characters</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CAC647C7D1E95B0">3.2-1 HeLP_WithGivenOrderSConstant</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B0FD19084B09AF8">3.2-2 HeLP_AddGaloisCharacterSums</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X86A4BB01819B625D">3.3 <span class="Heading">Checks for all orders</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8727639883F787C5">3.3-1 HeLP_AllOrders</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C00E1567BFF1757">3.3-2 HeLP_AllOrdersPQ</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79C24763800E48E9">3.3-3 HeLP_AllOrdersSP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81E3FEE678B0FDD5">3.3-4 HeLP_AllOrdersKP</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7E81639F8186F858">3.4 <span class="Heading">Changing the used Character Table</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BB9009482784E90">3.4-1 HeLP_ChangeCharKeepSols</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C19F3A378AAF294">3.4-2 HeLP_Reset</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A05180B7DA5EB77">3.5 <span class="Heading">Influencing how the Systems of Inequalities are solved</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B2326C5813CF36B">3.5-1 HeLP_Solver</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A7536D9790C1901">3.5-2 HeLP_UseRedund</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F6C4FAD805CD7FC">3.5-3 HeLP_Change4ti2Precision</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8490447A857CFD87">3.5-4 HeLP_Vertices</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7990EC037D6AE938">3.6 <span class="Heading">Checking solutions, calculating and checking solutions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DAA7EF785621D9E">3.6-1 HeLP_VerifySolution</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8452B7F58641E7F5">3.6-2 HeLP_FindAndVerifySolution</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81E4BAF2815051C4">3.6-3 HeLP_PossiblePartialAugmentationsOfPowers</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E37E3767B7085B9">3.6-4 HeLP_WriteTrivialSolution</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7BA77C9F86ADD546">3.7 <span class="Heading">The Wagner test</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79349D80830FA89B">3.7-1 HeLP_WagnerTest</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7FCFA1227B958BC0">3.8 <span class="Heading">Action of the automorphism group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80E976FE781AC904">3.8-1 HeLP_AutomorphismOrbits</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X84DD5181826CA1C2">3.9 <span class="Heading">Output</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A5CAEBD801EF192">3.9-1 HeLP_PrintSolution</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7F88D4667910126A">3.10 <span class="Heading">Eigenvalue multiplicities and character values</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86601BE281C7B8B6">3.10-1 HeLP_MultiplicitiesOfEigenvalues</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C4C37B681A5BC7D">3.10-2 HeLP_CharacterValue</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8668C68E7C07EF99">3.11 <span class="Heading">Check for triviality modulo normal subgroup</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X819973897A847FFE">3.11-1 HeLP_IsOneModuloN</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87E2729184EB30B3">3.11-2 HeLP_ForgetUnderlyingGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X87C19C44801003CD">3.12 <span class="Heading">Check Kimmerle Problem for single units</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E8B60D97999264E">3.12-1 HeLP_UnitSatisfiesKP</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X828D02D784AF3DFF">3.13 <span class="Heading">Check whether Zassenhaus Conjecture is known from theoretical results</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80E52D94801193C4">3.13-1 HeLP_IsZCKnown</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Further functions</span></h3>

<p>A short remark is probably in order on the three global variables the package is using: <code class="keyw">HeLP_CT</code>, <code class="keyw">HeLP_sol</code> and <code class="keyw">HeLP_settings</code>. The first one stores the character table for which the last calculations were performed, the second one containing at the <code class="keyw">k</code>'s spot the already calculated admissible partial augmentations of elements of order <span class="Math">k</span> (and its powers <span class="Math">u^d</span> for <span class="Math">d \not= k</span> a divisor of <span class="Math">k</span>). If a function of the HeLP-package is called with a character table different from the one saved in <code class="keyw">HeLP_CT</code> then the package tries to check if the character tables belong to the same group. This can be done in particular for tables from the ATLAS. If this check is successful the solutions already written in <code class="keyw">HeLP_sol</code> are kept, otherwise this variable is reset. For a more detailed account see Sections <a href="chap4.html#X84ED1F0D7A47B055"><span class="RefLink">4.2</span></a>, <a href="chap5.html#X7E2BFEC182B09895"><span class="RefLink">5.2</span></a> and <code class="func">HeLP_ChangeCharKeepSols</code> (<a href="chap3.html#X7BB9009482784E90"><span class="RefLink">3.4-1</span></a>). In most situations, the user does not have to worry about this, the program will take care of it as far as possible. <code class="keyw">HeLP_settings</code> is a varaible which is used to store some settings on how linear inequalities are solved by the package.</p>

<p><a id="X85F252368293DB34" name="X85F252368293DB34"></a></p>

<h4>3.1 <span class="Heading">Checks for specific orders</span></h4>

<p><a id="X7F8F6E3D80A23C1D" name="X7F8F6E3D80A23C1D"></a></p>

<h5>3.1-1 HeLP_WithGivenOrder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_WithGivenOrder</code>( <var class="Arg">CharacterTable|ListOfClassFunctions</var>, <var class="Arg">ord</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations</p>

<p>Calculates the admissible partial augmentations for elements of order <var class="Arg">ord</var> using only the data given in the first argument. The first argument can be an ordinary character table, a Brauer table, or a list of class functions, all having the same underlying character table. This function only uses the constraints of the HeLP method (from the class functions given), but does not apply the Wagner test <a href="chap5.html#X7BA77C9F86ADD546"><span class="RefLink">5.4</span></a>. If the constraints allow only a finite number of solutions, these lists will be written in <code class="keyw">HeLP_sol[ord]</code>. If for divisors <span class="SimpleMath">d</span> of <var class="Arg">ord</var> solutions are already calculated and stored in <code class="keyw">HeLP_sol[d]</code>, these will be used, otherwise the function <code class="keyw">HeLP_WithGivenOrder</code> will first be applied to this order and the data given in the first argument.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A5");</span>
CharacterTable( "A5" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 5);</span>
#I  Number of solutions for elements of order 5: 2; stored in HeLP_sol[5].
[ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_PrintSolution(5);</span>
Solutions for elements of order 5:
[ [               u ],.
  [  [ "5a", "5b" ] ],
  [             --- ],
  [        [ 0, 1 ] ],
  [        [ 1, 0 ] ] ]
</pre></div>

<p>Tests which partial augmentations for elements of order 5 are admissible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A6");</span>
CharacterTable( "A6" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 4);</span>
#I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
[ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
  [ [ 1 ], [ 0, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[4];              </span>
[ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
  [ [ 1 ], [ 0, 1 ] ] ]
</pre></div>

<p>Two of the non-trivial partial augmentations can be eliminated by using the Brauer table modulo the prime <span class="Math">3</span>:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C mod 3, 4);                                                                    </span>
#I  Number of solutions for elements of order 4: 2; stored in HeLP_sol[4].
[ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
</pre></div>

<p>When using <code class="keyw">HeLP_ZC</code> also the last remaining non-trivial partial augmentation disappears, as this function applies the Wagner test, cf. <a href="chap5.html#X7BA77C9F86ADD546"><span class="RefLink">5.4</span></a> and <code class="func">HeLP_WagnerTest</code> (<a href="chap3.html#X79349D80830FA89B"><span class="RefLink">3.7-1</span></a>):</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);               </span>
#I  ZC can't be solved, using the given data, for the orders: [ 6 ].
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[4]; HeLP_sol[6];</span>
[ [ [ 1 ], [ 0, 1 ] ] ]
[ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
</pre></div>

<p>The following example demonstrates how one can use lists of characters to obtain constraints for partial augmentations:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("L2(49).2_1");   </span>
CharacterTable( "L2(49).2_1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(Irr(C), 7);;</span>
#I  Number of solutions for elements of order 7: 1; stored in HeLP_sol[7].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(Irr(C){[2]}, 14);</span>
#I  The given data admit infinitely many solutions for elements of order 14.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(Irr(C){[44]}, 14);</span>
#I  The given data admit infinitely many solutions for elements of order 14.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(Irr(C){[2,44]}, 14);</span>
#I  Number of solutions for elements of order 14: 0; stored in HeLP_sol[14].
[  ]
</pre></div>

<p>Brauer tables can provide more restrictions on partial augmentations of certain torsion units:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("J1");       </span>
CharacterTable( "J1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 6);;</span>
#I  Number of solutions for elements of order 6: 73; stored in HeLP_sol[6].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := C mod 11;</span>
BrauerTable( "J1", 11 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(B, 6);;       </span>
#I  Number of solutions for elements of order 6: 6; stored in HeLP_sol[6].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(Irr(B){[2,3]}, 6);;</span>
#I  Number of solutions for elements of order 6: 6; stored in HeLP_sol[6].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_PrintSolution(6);</span>
Solutions for elements of order 6:
[ [                   u^3,                   u^2,                     u ],
  [              [ "2a" ],              [ "3a" ],  [ "2a", "3a", "6a" ] ],
  [                   ---,                   ---,                   --- ],
  [                 [ 1 ],                 [ 1 ],          [ -2, 0, 3 ] ],
  [                 [ 1 ],                 [ 1 ],          [ 2, 0, -1 ] ],
  [                 [ 1 ],                 [ 1 ],           [ 0, 0, 1 ] ],
  [                 [ 1 ],                 [ 1 ],          [ -4, 3, 2 ] ],
  [                 [ 1 ],                 [ 1 ],          [ 0, 3, -2 ] ],
  [                 [ 1 ],                 [ 1 ],          [ -2, 3, 0 ] ] ]
</pre></div>

<p>The result of the previous example can be found in <a href="chapBib.html#biBBJK">[BJK11]</a>. The existence of such units was later excluded in <a href="chapBib.html#biBBachleMargolisExamplesToMethods">[BM21]</a>.</p>

<p>When dealing with many variables using lists of characters instead of a complete character table might also speed up the calculations a lot, see Section <a href="chap4.html#X7E939D8483F1EE64"><span class="RefLink">4.3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("L2(27)");</span>
CharacterTable( "L2(27)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C,7);;</span>
#I  Number of solutions for elements of order 7: 78; stored in HeLP_sol[7].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(HeLP_Info,4);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C,3*7); </span>
#I      Solutions for order 3 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 21: 0; stored in HeLP_sol[21].  
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(HeLP_Info,1);</span>
</pre></div>

<p><code class="keyw">HeLP_WithGivenOrder</code> often needs to consider many cases. Set the info class HeLP_Info to a level 4 or higher to keep track of the progress, see Section <a href="chap4.html#X8242093A82FE41FA"><span class="RefLink">4.4</span></a> on info levels.</p>

<p><a id="X7CD0CEF283F13F7B" name="X7CD0CEF283F13F7B"></a></p>

<h5>3.1-2 HeLP_WithGivenOrderAndPA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_WithGivenOrderAndPA</code>( <var class="Arg">CharacterTable|ListOfClassFunctions</var>, <var class="Arg">ord</var>, <var class="Arg">partaugs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations</p>

<p>Calculates the admissible partial augmentations for elements of order <var class="Arg">ord</var> using only the data given in the first argument. The first argument can be an ordinary character table, a Brauer table, or a list of class functions, all having the same underlying character table. The function uses the partial augmentations for the powers <span class="SimpleMath">u^d</span> with <span class="SimpleMath">d</span> divisors of <span class="SimpleMath">k</span> different from <span class="SimpleMath">1</span> and <span class="SimpleMath">k</span> given in <var class="Arg">partaugs</var>. Here, the <span class="SimpleMath">d</span>'s have to be in a descending order (i.e. the orders of the <span class="Math">u^d</span>'s are ascending). This function only uses the constraints of the HeLP method, but does not apply the Wagner test <a href="chap5.html#X7BA77C9F86ADD546"><span class="RefLink">5.4</span></a>. Note that this function will not affect <code class="keyw">HeLP_sol</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup(48,33);; StructureDescription(G);</span>
"SL(2,3) : C2"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 4);;</span>
#I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 6);;</span>
#I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[4]; HeLP_sol[6];</span>
[ [ [ 1, 0 ], [ 0, 1, 0, 0, 0 ] ], [ [ 1, 0 ], [ 0, 0, 0, 0, 1 ] ], 
  [ [ 1, 0 ], [ 0, 0, 0, 1, 0 ] ], [ [ 1, 0 ], [ 0, 0, 1, 0, 0 ] ] ]
[ [ [ 1, 0 ], [ 0, 1 ], [ 0, 0, 0, 0, 1, 0 ] ], 
  [ [ 1, 0 ], [ 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderAndPA(C, 12, [ [ 1, 0 ],  [ 0, 1 ], [ 0, 0, 0, 0, 1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ 0, 0, 0, 0, 1, 0 ] ]); </span>
#I  Number of solutions for elements of order 12 with these partial augmentation
s for the powers: 1.
[ [ [ 1, 0 ], [ 0, 1 ], [ 0, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 1, 0 ], 
      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderAndPA(C, 12, [ [ 1, 0 ],  [ 0, 1 ], [ 0, 0, 0, 1, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ 0, 0, 0, 0, 1, 0 ] ]);</span>
#I  Number of solutions for elements of order 12 with these partial augmentation
s for the powers: 0.
[  ]
</pre></div>

<p>In the calls of <code class="keyw">HeLP_WithGivenOrderAndPA</code> the function uses the following partial augmentations:</p>


<ul>
<li><p><code class="keyw">[ 1, 0 ]</code> for the element <span class="SimpleMath">u^6</span> of order 2,</p>

</li>
<li><p><code class="keyw">[ 0, 1 ]</code> for the element <span class="SimpleMath">u^4</span> of order 3,</p>

</li>
<li><p><code class="keyw">[ 0, 0, 0, 0, 1 ]</code> and <code class="keyw">[ 0, 0, 0, 1, 0 ]</code> for the element <span class="SimpleMath">u^3</span> of order 4 respectively,</p>

</li>
<li><p><code class="keyw">[ 0, 0, 0, 0, 1, 0 ]</code> for the element <span class="SimpleMath">u^2</span> of order 6.</p>

</li>
</ul>
<p><a id="X8186F17681AF25F5" name="X8186F17681AF25F5"></a></p>

<h5>3.1-3 HeLP_WithGivenOrderAllTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_WithGivenOrderAllTables</code>( <var class="Arg">CharacterTable</var>, <var class="Arg">ord</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations</p>

<p>Calculates the admissible partial augmentations for elements of order <var class="Arg">ord</var> using the given character table <var class="Arg">CharacterTable</var> and all Brauer tables that can be obtained from it. <var class="Arg">CharacterTable</var> can be an ordinary or a Brauer table. In any case, then given table will be used first to obtain a finite number of solutions (if the characteristic does not divide <var class="Arg">ord</var>, otherwise the ordinary table will be used), with the other tables only checks will be performed to restrict the number of possible partial augmentations as much as possible. If certain Brauer tables are not avaialble, this will be printed if HeLP_Info is at least 1. This function only uses the constraints of the HeLP method, but does not apply the Wagner test <a href="chap5.html#X7BA77C9F86ADD546"><span class="RefLink">5.4</span></a>. If the constraints allow only a finite number of solutions, these lists will be written in <code class="keyw">HeLP_sol[ord]</code>. If for divisors <span class="SimpleMath">d</span> of <var class="Arg">ord</var> solutions are already calculated and stored in <code class="keyw">HeLP_sol[d]</code>, these will be used, otherwise the function <code class="keyw">HeLP_WithGivenOrder</code> will first be applied to this order and the data given in the first argument.</p>

<p><a id="X81063633815E39CE" name="X81063633815E39CE"></a></p>

<h5>3.1-4 HeLP_WithGivenOrderAndPAAllTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_WithGivenOrderAndPAAllTables</code>( <var class="Arg">CharacterTable</var>, <var class="Arg">ord</var>, <var class="Arg">partaugs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations</p>

<p>Calculates the admissible partial augmentations for elements of order <var class="Arg">ord</var> using the given character table <var class="Arg">CharacterTable</var> and all other tables that can be obtained from it. <var class="Arg">CharacterTable</var> can be an ordinary or a Brauer table. In any case, then given table will be used first to obtain a finite number of solutions (if the characteristic does not divide <var class="Arg">ord</var>, otherwise the ordinary table will be used), with the other tables only checks will be performed to restrict the number of possible partial augmentations as much as possible. If certain Brauer tables are not avaialble, this will be printed if HeLP_Info is at least 1. The function uses the partial augmentations for the powers <span class="SimpleMath">u^d</span> with <span class="SimpleMath">d</span> divisors of <span class="SimpleMath">k</span> different from <span class="SimpleMath">1</span> and <span class="SimpleMath">k</span> given in <var class="Arg">partaugs</var>. Here, the <span class="SimpleMath">d</span>'s have to be in a descending order (i.e. the orders of the <span class="Math">u^d</span>'s are ascending). This function only uses the constraints of the HeLP method, but does not apply the Wagner test <a href="chap5.html#X7BA77C9F86ADD546"><span class="RefLink">5.4</span></a>. Note that this function will not affect <code class="keyw">HeLP_sol</code>.</p>

<p><a id="X80D9773D86873CB2" name="X80D9773D86873CB2"></a></p>

<h5>3.1-5 HeLP_WithGivenOrderAndPAAndSpecificSystem</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_WithGivenOrderAndPAAndSpecificSystem</code>( <var class="Arg">list</var>, <var class="Arg">ord</var>, <var class="Arg">partaugs</var>[, <var class="Arg">b</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations</p>

<p>Calculates the admissible partial augmentations for elements of order <var class="Arg">ord</var> using only the data given in the first argument. The first argument is a list, which can contains as entries characters or pairs with first entry a character and second entrie an integer or a mixture of these. The first argument is understood as follows: If a character <span class="SimpleMath">χ</span> is not given in a pair all inequalities obtainable by this character are used. If it is given in a pair with the integer <span class="SimpleMath">m</span> the inequalities obtainable from the multiplicity of <code class="keyw">E(ord)</code> taken to the power <span class="SimpleMath">m</span> as an eigenvalue of a representation affording <span class="SimpleMath">χ</span> are used. The function uses the partial augmentations for the powers <span class="SimpleMath">u^d</span> with <span class="SimpleMath">d</span> divisors of <span class="SimpleMath">k</span> different from <span class="SimpleMath">1</span> and <span class="SimpleMath">k</span> given in <var class="Arg">partaugs</var>. Here, the <span class="SimpleMath">d</span>'s have to be in a descending order (i.e. the orders of the <span class="Math">u^d</span>'s are ascending). This function only uses the constraints of the HeLP method, but does not apply the Wagner test <a href="chap5.html#X7BA77C9F86ADD546"><span class="RefLink">5.4</span></a>. Note that this function will not affect <code class="keyw">HeLP_sol</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A5");</span>
CharacterTable( "A5" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi := Irr(C)[2];; psi := Irr(C)[4];</span>
Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderAndPAAndSpecificSystem([[chi, 1], [chi, 2]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> 5, [ ], true);</span>
[ [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ], [ [ -3/5, 2/5 ], [ 2/5, -3/5 ] ], [ 3/5, 3/5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sol5 := HeLP_WithGivenOrderAndPAAndSpecificSystem([[chi, 1], [chi, 2]], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> 5, [ ]);      </span>
[ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
</pre></div>

<p>The inequalities in the above examples are:</p>

<p class="pcenter">\frac{-3}{5}\varepsilon_{5a}(u) + \frac{2}{5}\varepsilon_{5b}(u) + \frac{3}{5} \in \mathbb{Z}_{\geq 0} \ \ {\rm{and}} \ \ \frac{2}{5}\varepsilon_{5a}(u) + \frac{-3}{5}\varepsilon_{5b}(u) + \frac{3}{5} \in \mathbb{Z}_{\geq 0}. </p>

<p>Continuing the above example:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderAndPAAndSpecificSystem([psi], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> 2*5, [[1], sol5[1][1]], true);     </span>
[ [  ], [ [ 0, -2/5, -2/5 ], [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ],
 [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ], [ 0, 2/5, 2/5 ], 
 [ 0, 1/10, 1/10 ], [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ], 
[ 0, -1/10, -1/10 ] ], [ 0, 1/2, 1/2, 1/2, 1/2, 0, 1/2, 1/2, 1/2, 1/2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderAndPAAndSpecificSystem([[psi, 0], [psi, 2], [psi, 5]], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> 2*5, [[1], sol5[2][1]], true); </span>
[ [  ], [ [ 0, -2/5, -2/5 ], [ 0, 1/10, 1/10 ], [ 0, 2/5, 2/5 ] ], [ 0, 1/2, 0 ] ]
</pre></div>

<p><a id="X7FCD80AC87DD0460" name="X7FCD80AC87DD0460"></a></p>

<h4>3.2 <span class="Heading">Checks for specific orders with s-constant characters</span></h4>

<p>When considering elements of order <span class="Math">st</span> (in absence of elements of this order in the group ; in particular when trying to prove (PQ)) and there are several conjugacy classes of elements of order <span class="Math">s</span>, it might be useful to consider <span class="Math">s</span>-constant characters (cf. Section <a href="chap5.html#X85810FF37EB3F4B4"><span class="RefLink">5.5</span></a>) to reduce the computational complexity.</p>

<p><a id="X7CAC647C7D1E95B0" name="X7CAC647C7D1E95B0"></a></p>

<h5>3.2-1 HeLP_WithGivenOrderSConstant</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_WithGivenOrderSConstant</code>( <var class="Arg">CharacterTable|ListOfClassFunctions</var>, <var class="Arg">s</var>, <var class="Arg">t</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible "partial augmentations" or <code class="keyw">"infinite"</code></p>

<p>Calculates the admissible partial augmentations for elements <span class="SimpleMath">u</span> of order <span class="SimpleMath">s*t</span> using only the <span class="Math">s</span>-constant class functions that are contained in the first argument. The first argument can be an ordinary character table, a Brauer table, or a list of class functions, all having the same underlying character table. <var class="Arg">s</var> and <var class="Arg">t</var> have to be different prime numbers, such that there are elements of order <var class="Arg">s</var> and <var class="Arg">t</var> in the group, but no elements of order <span class="SimpleMath">s*t</span>.</p>

<p>The function filters which class functions given in the first argument are constant on all conjugacy classes of elements of order <var class="Arg">s</var>. For the element <span class="SimpleMath">u^s</span> of order <var class="Arg">t</var> the partial augmentations given in <code class="keyw">HeLP_sol[t]</code> are used. If they are not yet calculated, the function calculates them first, using the data given in the first argument and stores them in <code class="keyw">HeLP_sol[t]</code>. This function only uses the constraints of the HeLP method, but does not apply the Wagner test <a href="chap5.html#X7BA77C9F86ADD546"><span class="RefLink">5.4</span></a>. If these calculations allow an infinite number of solutions of elements of order <span class="Math">st</span> the function returns <code class="keyw">"infinite"</code>, otherwiese it returns the finite list of solutions for elements of order <span class="SimpleMath">s*t</span>. The first entry of every solution is a list of the partial augmentations of <span class="SimpleMath">u^s</span> and the second entry is a list of the "partial augmentations" for <span class="SimpleMath">u</span>: the first entry of this list is the sum of the partial augmentations on all classes of elements of order <var class="Arg">s</var> and the other entries are the partial augmentations on the classes of order <var class="Arg">t</var>. Only in the case that the existence of units of order <span class="Math">s*t</span> can be excluded by this function the variable <code class="keyw">HeLP_sol[s*t]</code> will be affected and <code class="keyw">HeLP_sol[s*t]</code> will be set to <code class="keyw">[ ]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A6");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 6);            </span>
#I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
[ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderSConstant(C, 2, 3);</span>
[ [ [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1, 0 ], [ -2, 1, 2 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderSConstant(C, 3, 2);     </span>
[ [ [ 1 ], [ 3, -2 ] ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("Sz(8)");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(HeLP_Info, 4);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderSConstant(C, 7, 13);</span>
#I    Partial augmentations for elements of order 13 not yet calculated.  Restar
t for this order.
#I    Number of non-trivial 7-constant characters in the list: 7.
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(HeLP_Info, 1);</span>
</pre></div>

<p>The last example can also be checked by using all characters in <code class="keyw">C</code>, but this takes notably longer.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("Sz(32)");</span>
CharacterTable( "Sz(32)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := Filtered(OrdersClassRepresentatives(C), x-&gt; x = 31);; Size(L);</span>
15           # I.e. HeLP_WithGivenOrder(C,31) would take hopelessly long
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderSConstant(C mod 2, 31, 5);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBound(HeLP_sol[31]);</span>
false 
</pre></div>

<p>We still have no clue about elements of order 31, but there are none of order 5*31.</p>

<p><a id="X7B0FD19084B09AF8" name="X7B0FD19084B09AF8"></a></p>

<h5>3.2-2 HeLP_AddGaloisCharacterSums</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_AddGaloisCharacterSums</code>( <var class="Arg">CT</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of characters</p>

<p>Given an ordinary character table <var class="Arg">CT</var> the function calculates the orbits under the action of the Galois group and returns a list of characters containing the ones contained in <var class="Arg">CT</var> and the ones obtained by summing up the Galois-orbits.</p>

<p><a id="X86A4BB01819B625D" name="X86A4BB01819B625D"></a></p>

<h4>3.3 <span class="Heading">Checks for all orders</span></h4>

<p><a id="X8727639883F787C5" name="X8727639883F787C5"></a></p>

<h5>3.3-1 HeLP_AllOrders</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_AllOrders</code>( <var class="Arg">CharacterTable|Group</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if (ZC) can be solved using the given data, <code class="keyw">false</code> otherwise</p>

<p>This function does almost the same as <code class="func">HeLP_ZC</code> (<a href="chap2.html#X81AF79A587054306"><span class="RefLink">2.1-1</span></a>). It checks whether the Zassenhaus Conjecture can be verified for a group, but does not compute the partial augmentations of elements of order <span class="Math">k</span>, if <code class="keyw">HeLP_sol[k]</code> already exists. It does however verify the solutions given in <code class="keyw">HeLP_sol</code> using all available tables for the group, see <code class="func">HeLP_VerifySolution</code> (<a href="chap3.html#X7DAA7EF785621D9E"><span class="RefLink">3.6-1</span></a>). Thus some precalculations using e.g. <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>) are respected. In contrast to <code class="func">HeLP_ZC</code> (<a href="chap2.html#X81AF79A587054306"><span class="RefLink">2.1-1</span></a>) this function also does not check whether the group is nilpotent to use the Weiss-result to have an immediate positive solution for (ZC).</p>

<p>This function is interesting if one wants to save time or possesses some information, which was not obtained using this package and was entered manually into <code class="keyw">HeLP_sol</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable(PSL(2,7));         </span>
CharacterTable( Group([ (3,7,5)(4,8,6), (1,2,6)(3,4,8) ]) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);        </span>
#I  The Brauer tables for the following primes are not available: [ 2, 3, 7 ].
#I  (ZC) can't be solved, using the given data, for the orders: [ 6 ].
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[6] := [ ];</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_AllOrders(C);</span>
true
</pre></div>

<p><a id="X7C00E1567BFF1757" name="X7C00E1567BFF1757"></a></p>

<h5>3.3-2 HeLP_AllOrdersPQ</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_AllOrdersPQ</code>( <var class="Arg">CharacterTable|Group</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if (PQ) can be solved using the given data, <code class="keyw">false</code> otherwise</p>

<p>This function does almost the same as <code class="func">HeLP_PQ</code> (<a href="chap2.html#X813A10398218E9EE"><span class="RefLink">2.2-1</span></a>). It checks whether the Prime Graph Question can be verified for a group, but does not compute the partial augmentations of elements of order <span class="Math">k</span>, if <code class="keyw">HeLP_sol[k]</code> already exists. Thus some precalculations using e.g. <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>) are respected. In contrast to <code class="func">HeLP_PQ</code> (<a href="chap2.html#X813A10398218E9EE"><span class="RefLink">2.2-1</span></a>) this function also does not check whether the group is solvable to use the Kimmerle-result to have an immediate positive solution for (PQ).</p>

<p>This function is interesting if one wants to save time or possesses some information, which was not obtained using this package and was entered manually into <code class="keyw">HeLP_sol</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A12");</span>
CharacterTable( "A12" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(Irr(C){[2, 4, 7]}, 2);;</span>
#I  Number of solutions for elements of order 2: 37; stored in HeLP_sol[2].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderSConstant(C mod 3,11,2);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(Irr(C mod 2){[2, 3, 4, 6]}, 3);;</span>
#I  Number of solutions for elements of order 3: 99; stored in HeLP_sol[3].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderSConstant(C mod 2, 11, 3);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_AllOrdersPQ(C);</span>
true
</pre></div>

<p>Thus the Prime Graph Question holds for the alternating group of degree 12. Just using <code class="keyw">HeLP_PQ(C)</code> would take hopelessly long.</p>

<p><a id="X79C24763800E48E9" name="X79C24763800E48E9"></a></p>

<h5>3.3-3 HeLP_AllOrdersSP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_AllOrdersSP</code>( <var class="Arg">CharacterTable|Group</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if (SP) can be solved using the given data, <code class="keyw">false</code> otherwise</p>

<p>This function does almost the same as <code class="func">HeLP_SP</code> (<a href="chap2.html#X84F8B60C8016DE7F"><span class="RefLink">2.3-1</span></a>). It checks whether the Spectrum Problem can be verified for a group, but does not compute the partial augmentations of elements of order <span class="Math">k</span>, if <code class="keyw">HeLP_sol[k]</code> already exists. Thus some precalculations using e.g. <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>) are respected. In contrast to <code class="func">HeLP_SP</code> (<a href="chap2.html#X84F8B60C8016DE7F"><span class="RefLink">2.3-1</span></a>) this function also does not check whether the group is solvable to use the Hertweck-result to have an immediate positive solution for (SP).</p>

<p>This function is interesting if one wants to save time or possesses some information, which was not obtained using this package and was entered manually into <code class="keyw">HeLP_sol</code>.</p>

<p><a id="X81E3FEE678B0FDD5" name="X81E3FEE678B0FDD5"></a></p>

<h5>3.3-4 HeLP_AllOrdersKP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_AllOrdersKP</code>( <var class="Arg">CharacterTable|Group</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if (KP) can be solved using the given data, <code class="keyw">false</code> otherwise</p>

<p>This function does almost the same as <code class="func">HeLP_KP</code> (<a href="chap2.html#X7CD90F897EEE8670"><span class="RefLink">2.4-1</span></a>). It checks whether the Kimmerle Problem can be verified for a group, but does not compute the partial augmentations of elements of order <span class="Math">k</span>, if <code class="keyw">HeLP_sol[k]</code> already exists. Thus some precalculations using e.g. <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>) are respected. In contrast to <code class="func">HeLP_KP</code> (<a href="chap2.html#X7CD90F897EEE8670"><span class="RefLink">2.4-1</span></a>) this function also does not check whether the group is nilpotent to use the Weiss-result to have an immediate positive solution for (KP).</p>

<p>This function is interesting if one wants to save time or possesses some information, which was not obtained using this package and was entered manually into <code class="keyw">HeLP_sol</code>.</p>

<p><a id="X7E81639F8186F858" name="X7E81639F8186F858"></a></p>

<h4>3.4 <span class="Heading">Changing the used Character Table</span></h4>

<p><a id="X7BB9009482784E90" name="X7BB9009482784E90"></a></p>

<h5>3.4-1 HeLP_ChangeCharKeepSols</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_ChangeCharKeepSols</code>( <var class="Arg">CT</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>This function changes the used character table to the character table <var class="Arg">CT</var> and keeps all the solutions calculated so far. It is in this case the responsibility of the user that the tables belong to the same group and the ordering of the conjugacy classes in <var class="Arg">CT</var> is consistent with the one in the previously used table. This function can be used to change from one table of the group to another, e.g. from a Brauer table to the ordinary table if the calculations will involve <span class="Math">p</span>-singular elements. (In case the involved character tables come from the ATLAS and their InfoText begins with "origin: ATLAS of finite groups", this is done automatically by the program.) A user may also use characters, which are normally not accessible in GAP.</p>

<p>To keep track of the change of the character tables one can set HeLP_Info to level 5. In this first example it is not realized that the character tables belong to the same group, so the solutions for elements of order 2 are recalculated (they have been reset, as another character table is used).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(HeLP_Info, 5);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable(SymmetricGroup(4)); </span>
CharacterTable( Sym( [ 1 .. 4 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C mod 2, 3); </span>
#I  USED CHARACTER TABLE CHANGED TO BrauerTable( SymmetricGroup( [ 1 .. 4 ] ), 2
 ), ALL GLOBAL VARIABLES RESET.
#I  Number of solutions for elements of order 3: 1; stored in HeLP_sol[3].
[ [ [ 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 2*3);    </span>
#I  USED CHARACTER TABLE CHANGED TO CharacterTable( SymmetricGroup( [ 1 .. 4 ] )
 ), ALL GLOBAL VARIABLES RESET.
#I      Solutions for order 2 not yet calculated.  Restart for this order.
#I      Solutions for order 3 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 6: 0; stored in HeLP_sol[6].
[  ]
</pre></div>

<p>The recalculations of the solutions can be avoided by calling <code class="keyw">HeLP_ChangeCharKeepSols</code> before using another character table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CharacterTable(SymmetricGroup(4));</span>
CharacterTable( Sym( [ 1 .. 4 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(D mod 2, 3);       </span>
#I  USED CHARACTER TABLE CHANGED TO BrauerTable( SymmetricGroup( [ 1 .. 4 ] ), 2
 ), ALL GLOBAL VARIABLES RESET.
#I  Number of solutions for elements of order 3: 1; stored in HeLP_sol[3].
[ [ [ 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ChangeCharKeepSols(D);</span>
#I  WARNING: Change used character table without checking if the character table
s have the same underlying groups and the ordering of the conjugacy classes are 
the same!
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(D, 2*3);    </span>
#I  Using same character table as until now; all known solutions kept.
#I      Solutions for order 2 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 6: 0; stored in HeLP_sol[6].
[  ]
</pre></div>

<p>When using tables from the ATLAS this is done automatically:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CA := CharacterTable("A5");</span>
CharacterTable( "A5" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(CA mod 2, 5);</span>
#I  USED CHARACTER TABLE CHANGED TO BrauerTable( "A5", 2 ), ALL GLOBAL VARIABLES
 RESET.
#I  Testing possibility 1 out of 1.
#I  Number of solutions for elements of order 5: 2; stored in HeLP_sol[5].
[ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(CA, 2*5);    </span>
#I  Using character table of the same group; all known solutions kept.
#I      Solutions for order 2 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 10: 0; stored in HeLP_sol[10].
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(HeLP_Info, 1);</span>
</pre></div>

<p><a id="X7C19F3A378AAF294" name="X7C19F3A378AAF294"></a></p>

<h5>3.4-2 HeLP_Reset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_Reset</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>This function delets all the values calculated so far and resets the global variables <code class="keyw">HeLP_CT</code> and <code class="keyw">HeLP_CT</code> to their initial value <code class="keyw">[ [ [1] ] ]</code> and <code class="keyw">CharacterTable(SmallGroup(1,1))</code> respectively.</p>

<p><a id="X7A05180B7DA5EB77" name="X7A05180B7DA5EB77"></a></p>

<h4>3.5 <span class="Heading">Influencing how the Systems of Inequalities are solved</span></h4>

<p>HeLP uses currently three external programs (i.e. programs that are not part of the GAP-system): zsolve from 4ti2 and/or normaliz to solve the systems of linear inequalities and redund from lrslib to simplify the inequlities before handing them over to the solver (HeLP can also be used without lrslib installed. In general it is recommanded to have lrslib installed, if 4ti2 is used as the solver). The following functions can be used to influence the behaviour of these external programms.</p>

<p><a id="X7B2326C5813CF36B" name="X7B2326C5813CF36B"></a></p>

<h5>3.5-1 HeLP_Solver</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_Solver</code>( [<var class="Arg">string</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>This function can be used to change the solver used for the HeLP-system between 4ti2 and normaliz. If the function is called without an argument it prints which solver is currently used. If the argument it is called with is one of the stings "4ti2" or "normaliz", then the solver used for future calculations is changed to the one given as argument in case this solver is found by the HeLP-package. If both solvers are found when the package is loaded normaliz is taken as default.</p>

<p><a id="X7A7536D9790C1901" name="X7A7536D9790C1901"></a></p>

<h5>3.5-2 HeLP_UseRedund</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_UseRedund</code>( <var class="Arg">bool</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>This function determines whether HeLP uses 'redund' from the lrslib-package to remove redundant equations from the HeLP system. If <var class="Arg">bool</var> is <code class="keyw">true</code> 'redund' will be used in all calculation that follow, if it is <code class="keyw">false</code>, 'redund' will not be used (which might take significantly longer). If 'redund' was not found by GAP a warning will be printed and the calculations will be performed without 'redund'. As default 'redund' will be used in all calculations, if 4ti2 is the chosen solver, and 'redund' will not be used, if normaliz is used.</p>

<p><a id="X7F6C4FAD805CD7FC" name="X7F6C4FAD805CD7FC"></a></p>

<h5>3.5-3 HeLP_Change4ti2Precision</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_Change4ti2Precision</code>( <var class="Arg">string</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>This function changes the maximum precision of the calculations of 4ti2 to solve the occurring systems of linear inequalities. The possible arguments are <code class="keyw">"32"</code>, <code class="keyw">"64"</code> and <code class="keyw">"gmp"</code>. After calling the function the new precision will be used until this function is used again. The default value is <code class="keyw">"32"</code>. A higher precision causes slower calculations. But this function might be used to increase the precision of 4ti2, when one gets an error message like "Error, 4ti2 Error: Results were near maximum precision (32bit). Please restart with higher precision!" stating that the results were close to the maximum 4ti2-precision. normaliz does automatically change its precision, when it reaches an overflow.</p>

<p>Sometimes it is desirable to perform calculations without redund (even if it is installed and in many cases improves the performance of the package) or with a higher precision. For example, determining the partial augmentations for units of order <span class="Math">14</span> for <code class="keyw">SmallGroup(392, 30)</code> involves very long calculations (when called with redund and precision 32) or cause errors (when called without redund and precision 32). However, the following works in a reasonable time.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable(SmallGroup(392,30));</span>
CharacterTable( &lt;pc group of size 392 with 5 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_Solver("4ti2");</span>
'4ti2' will be used from now on.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_UseRedund(false);</span>
The calculations will be performed without using 'redund' from now on.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);</span>
Error, 4ti2 Error:
Results were near maximum precision (32bit).
Please restart with higher precision!
If you continue, your results might be wrong called from
4ti2Interface_zsolve_equalities_and_inequalities( 
 [ ListWithIdenticalEntries( Size( T[1] ), 1 ) ], [ 1 ], temp[1], - temp[2] 
 ) called from
HeLP_TestSystemINTERNAL( W[1], W[2], k, arg[3] ) called from
HeLP_WithGivenOrderAndPAINTERNAL( C, k, pa ) called from
HeLP_WithGivenOrderINTERNAL( Irr( T ), k ) called from
&lt;function "HeLP_ZC"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 19 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">brk&gt; quit;</span>
#I  Options stack has been reset
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_Change4ti2Precision("64");</span>
The calculations of 4ti2 will be performed with precision 64 from now on.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);</span>
true
</pre></div>

<p>The reproducibility of the above example depends on the versions of the progrmas involved and probably also your machine.</p>

<p><a id="X8490447A857CFD87" name="X8490447A857CFD87"></a></p>

<h5>3.5-4 HeLP_Vertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_Vertices</code>( <var class="Arg">string</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>If normaliz is used as the solver of the HeLP-system this function influences, whether the "VerticesOfPolyhedron" are computed by normaliz. By default these are only computed, if the system has a trivial solution. The function takes "vertices", "novertices" and "default" as arguments. If you do not understand what this means, don't worry.</p>

<p><a id="X7990EC037D6AE938" name="X7990EC037D6AE938"></a></p>

<h4>3.6 <span class="Heading">Checking solutions, calculating and checking solutions</span></h4>

<p><a id="X7DAA7EF785621D9E" name="X7DAA7EF785621D9E"></a></p>

<h5>3.6-1 HeLP_VerifySolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_VerifySolution</code>( <var class="Arg">CharacterTable|ListOfClassFunctions</var>, <var class="Arg">k</var>[, <var class="Arg">list_paraugs</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations</p>

<p>This function checks which of the partial augmentations for elements of order <code class="keyw">k</code> given in <code class="keyw">HeLP_sol[k]</code> or the optional third argument <code class="keyw">list_paraugs</code> fulfill the HeLP equations obtained from the characters in the first argument. This function does not solve any inequalities, but only checks, if the given partial augmentations fulfill them. It is for this reason often faster then e.g. <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>).</p>

<p>If there is no third argument given, i.e. the augmentations from <code class="keyw">HeLP_sol[k]</code> are used, the result overwrites <code class="keyw">HeLP_sol[k]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A6");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 4);</span>
#I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
[ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
  [ [ 1 ], [ 0, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_VerifySolution(C mod 3, 4);</span>
[ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[4];</span>
[ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("S12");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(Irr(C mod 5){[2..6]}, 2);;</span>
#I  Number of solutions for elements of order 2: 563; stored in HeLP_sol[2].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_VerifySolution(C mod 5, 2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(HeLP_sol[2]);</span>
387
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_VerifySolution(C mod 3, 2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(HeLP_sol[2]);</span>
324
</pre></div>

<p>Using <code class="keyw">HeLP_WithGivenOrder(C mod 5, 2)</code> or <code class="keyw">HeLP_WithGivenOrder(C mod 3, 2)</code> takes much longer since in that case a bigger system of inequalities must be solved.</p>

<p><a id="X8452B7F58641E7F5" name="X8452B7F58641E7F5"></a></p>

<h5>3.6-2 HeLP_FindAndVerifySolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_FindAndVerifySolution</code>( <var class="Arg">CharacterTable|ListOfClassFunctions</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations or "infinite"</p>

<p>This function provides the same functionality as <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>) but instead of constructiong the corresponding system with all characters from the first argument <var class="Arg">CharacterTable|ListOfClassFunctions</var> it does it consecutively with larger sets of characters from the argument until a finite list of solutions is found and then applies <code class="func">HeLP_VerifySolution</code> (<a href="chap3.html#X7DAA7EF785621D9E"><span class="RefLink">3.6-1</span></a>) to these solutions with the entirety of the class functions in the first argument.</p>

<p>This function is sometimes faster than <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>), but the output is the same, thus the examples from <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>) also apply here.</p>

<p><a id="X81E4BAF2815051C4" name="X81E4BAF2815051C4"></a></p>

<h5>3.6-3 HeLP_PossiblePartialAugmentationsOfPowers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_PossiblePartialAugmentationsOfPowers</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of partial augmentations of powers.</p>

<p>This function provides the possible partial augmentations of the powers of units of a given order <span class="Math">n,</span> if the partial augmentations if units of order <span class="Math">n/p</span> have been already computed for all primes <span class="Math">p</span> dividing <span class="Math">n.</span> The possibilities are sorted in the same way as, if the order <span class="Math">n</span> is checked with any other function like e.g. <code class="func">HeLP_WithGivenOrder</code> (<a href="chap3.html#X7F8F6E3D80A23C1D"><span class="RefLink">3.1-1</span></a>) or <code class="func">HeLP_ZC</code> (<a href="chap2.html#X81AF79A587054306"><span class="RefLink">2.1-1</span></a>). Thus, if the InfoLevel is high enough and one obtains that the computation of some possibility is taking too long, one can check it using <code class="func">HeLP_WithGivenOrderAndPA</code> (<a href="chap3.html#X7CD0CEF283F13F7B"><span class="RefLink">3.1-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(HeLP_Info,4);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable(SmallGroup(160,91));</span>
CharacterTable( &lt;pc group of size 160 with 6 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C,4);;</span>
#I      Solutions for order 2 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 4: 22; stored in HeLP_sol[4].   
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C,10);;</span>
#I      Solutions for order 5 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 10: 6; stored in HeLP_sol[10].  
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LP := HeLP_PossiblePartialAugmentationsOfPowers(20);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrderAndPA(Irr(C){[2..20]},20,LP[1]);</span>
#I  Number of solutions for elements of order 20 with these partial augmentations
 for the powers: 0.
[  ]
</pre></div>

<p><a id="X7E37E3767B7085B9" name="X7E37E3767B7085B9"></a></p>

<h5>3.6-4 HeLP_WriteTrivialSolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_WriteTrivialSolution</code>( <var class="Arg">C</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: Trivial solutions.</p>

<p>Given a character table <var class="Arg">C</var> and an order <var class="Arg">k</var>, the function calculates the partial augmentations of units of order <span class="Math">k</span> that are rationally conjugate to group elements (note that they just coincide with the partial augmentations of group elements) and stores them in <code class="keyw">HeLP_sol[k]</code>. If solutions of order <span class="Math">k</span> were already calculated, they are overwritten by this function, so this function can be used in particular if elements of order <span class="Math">k</span> are known to be rationally conjugate to group elements by theoretical results.</p>

<p>With the character tables that are currently available in GAP, the Zassenhaus Conjecture for elements of order <span class="Math">4</span> in <span class="Math">\text{PSL}(2,49)</span> cannot be solved. However it was proved in <a href="chapBib.html#biBHertweckBrauer">[Her07]</a> using the Brauer table modulo <span class="Math">7</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("L2(49)");</span>
CharacterTable( "L2(49)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 4);</span>
#I  Number of solutions for elements of order 4: 14; stored in HeLP_sol[4].
[ [ [ 1 ], [ -6, 7 ] ], [ [ 1 ], [ -5, 6 ] ], [ [ 1 ], [ -4, 5 ] ], 
  [ [ 1 ], [ -3, 4 ] ], [ [ 1 ], [ -2, 3 ] ], [ [ 1 ], [ -1, 2 ] ], 
  [ [ 1 ], [ 0, 1 ] ], [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 2, -1 ] ], 
  [ [ 1 ], [ 3, -2 ] ], [ [ 1 ], [ 4, -3 ] ], [ [ 1 ], [ 5, -4 ] ], 
  [ [ 1 ], [ 6, -5 ] ], [ [ 1 ], [ 7, -6 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C mod 7;</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WriteTrivialSolution(C, 4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[4];</span>
[ [ [ 1 ], [ 0, 1 ] ] ]
</pre></div>

<p><a id="X7BA77C9F86ADD546" name="X7BA77C9F86ADD546"></a></p>

<h4>3.7 <span class="Heading">The Wagner test</span></h4>

<p><a id="X79349D80830FA89B" name="X79349D80830FA89B"></a></p>

<h5>3.7-1 HeLP_WagnerTest</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_WagnerTest</code>( <var class="Arg">k</var>[, <var class="Arg">list_paraugs</var>, <var class="Arg">OrdinaryCharacterTable</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations</p>

<p>This function applies the Wagner test (cf. Section <a href="chap5.html#X7BA77C9F86ADD546"><span class="RefLink">5.4</span></a>) to the given data. If only the order <var class="Arg">k</var> is given as argument, the Wagner test will be applied to the solutions stored in <code class="keyw">HeLP_sol[k]</code>. If the arguments are the order <var class="Arg">k</var>, a list of possible solutions <var class="Arg">list_paraugs</var> and an ordinary character table <var class="Arg">OrdinaryCharacterTable</var> it applies the test to the solutions given in <var class="Arg">list_paraugs</var> and using the number of conjugacy classes for elements a divisor of <var class="Arg">k</var>, which will be extracted from the head of <var class="Arg">OrdinaryCharacterTable</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("M11");</span>
CharacterTable( "M11" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C,8);;</span>
#I  Number of solutions for elements of order 8: 36; stored in HeLP_sol[8].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[8] := HeLP_WagnerTest(8);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(HeLP_sol[8]);</span>
24
</pre></div>

<p>Thus the Wagner-Test eliminates 12 possible partial augmentations for elements of order 8. Continuing the example:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C,12);</span>
#I  Number of solutions for elements of order 12: 7; stored in HeLP_sol[12].
[ [ [ 1 ], [ 1 ], [ 2, -1 ], [ 0, 3, -2 ], [ 1, 0, -1, 1 ] ], 
  [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, 3, -2 ], [ 0, 0, 0, 1 ] ], 
  [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, 3, -2 ], [ 0, 0, 2, -1 ] ], 
  [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ 1, 0, 1, -1 ] ], 
  [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ -1, 0, 1, 1 ] ], 
  [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, -3, 4 ], [ 0, 0, 0, 1 ] ], 
  [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, -3, 4 ], [ 1, 0, -1, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[12] := HeLP_WagnerTest(12);</span>
[ [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, 3, -2 ], [ 0, 0, 0, 1 ] ], 
  [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, 3, -2 ], [ 0, 0, 2, -1 ] ], 
  [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, -3, 4 ], [ 0, 0, 0, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[4] := HeLP_WagnerTest(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C,12);</span>
#I  Number of solutions for elements of order 12: 3; stored in HeLP_sol[12].
[ [ [ 1 ], [ 1 ], [ 2, -1 ], [ 0, 3, -2 ], [ 1, 0, -1, 1 ] ], 
  [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ 1, 0, 1, -1 ] ], 
  [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ -1, 0, 1, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[12] := HeLP_WagnerTest(12);</span>
[  ]
</pre></div>

<p>Thus there are no normalized units of order 12 in the integral group ring of <span class="Math">M_{11}.</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("M22");</span>
CharacterTable( "M22" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WagnerTest(12, [ [ [1], [1], [1,0], [0,0,1], [-3,3,2,3,-4] ] ],C);</span>
[  ]
</pre></div>

<p>This example is taken from the appendix of <a href="chapBib.html#biBKonovalovM22">[BKL08]</a>.</p>

<p>Sometimes the Wagner-Test may even prove the Zassenhaus Conjecture:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup(96,187);</span>
&lt;pc group of size 96 with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable(G);</span>
CharacterTable( &lt;pc group of size 96 with 6 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C,4);;</span>
#I  Number of solutions for elements of order 4: 34; stored in HeLP_sol[4].
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WagnerTest(4);       </span>
[ [ [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 1 ] ],
  [ [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 1, 0, 0 ] ],
  [ [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1, 0, 0, 0 ] ], 
  [ [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 1, 0 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);</span>
true
</pre></div>

<p><a id="X7FCFA1227B958BC0" name="X7FCFA1227B958BC0"></a></p>

<h4>3.8 <span class="Heading">Action of the automorphism group</span></h4>

<p><a id="X80E976FE781AC904" name="X80E976FE781AC904"></a></p>

<h5>3.8-1 HeLP_AutomorphismOrbits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_AutomorphismOrbits</code>( <var class="Arg">C</var>, <var class="Arg">k</var>[, <var class="Arg">list_paraug</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: List of admissible partial augmentations</p>

<p>For a list of possible partial augmentations, this function calculates representatives of each orbit of the action of the automorphism group of <span class="Math">G</span> on them. The first two mandatory arguments are an ordinary character table <var class="Arg">C</var> (with an underlying group) and the order <var class="Arg">k</var> for which the partial augmentations should be filtered with respect to the action of the automorphism group of <span class="Math">G</span>. If as third argument a list of partial augmentations is given, then these will be used, otherwise the partial augmentations that are stored in <code class="keyw">HeLP_sol[k]</code> are used.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A6");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 6);</span>
#I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
[ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_AutomorphismOrbits(C, 6);</span>
[ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ] ]
</pre></div>

<p><a id="X84DD5181826CA1C2" name="X84DD5181826CA1C2"></a></p>

<h4>3.9 <span class="Heading">Output</span></h4>

<p><a id="X7A5CAEBD801EF192" name="X7A5CAEBD801EF192"></a></p>

<h5>3.9-1 HeLP_PrintSolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_PrintSolution</code>( [<var class="Arg">k</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>This function prints the possible solutions in a pretty way. If a positive integer <var class="Arg">k</var> as argument is given, then it prints the admissible partial augmentations of units of order <var class="Arg">k</var>, if they are already calculated. If no argument is given, the function prints information on all orders for which there is already some information available.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A5");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);          </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_PrintSolution();</span>
Solutions for elements of order 2:
[ [         u ],
  [  [ "2a" ] ],
  [       --- ],
  [     [ 1 ] ] ]
Solutions for elements of order 3:
[ [         u ],
  [  [ "3a" ] ],
  [       --- ],
  [     [ 1 ] ] ]
Solutions for elements of order 5:
[ [               u ],
  [  [ "5a", "5b" ] ],
  [             --- ],
  [        [ 0, 1 ] ],
  [        [ 1, 0 ] ] ]
There are no admissible partial augmentations for elements of order 6.
There are no admissible partial augmentations for elements of order 10.
There are no admissible partial augmentations for elements of order 15.
There are no admissible partial augmentations for elements of order 30.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A6");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);           </span>
#I  ZC can't be solved, using the given data, for the orders: [ 6 ].
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_PrintSolution(6);</span>
Solutions for elements of order 6:
[ [                   u^3,                   u^2,                     u ],
  [              [ "2a" ],        [ "3a", "3b" ],  [ "2a", "3a", "3b" ] ],
  [                   ---,                   ---,                   --- ],
  [                 [ 1 ],              [ 0, 1 ],          [ -2, 2, 1 ] ],
  [                 [ 1 ],              [ 1, 0 ],          [ -2, 1, 2 ] ] ]
</pre></div>

<p><a id="X7F88D4667910126A" name="X7F88D4667910126A"></a></p>

<h4>3.10 <span class="Heading">Eigenvalue multiplicities and character values</span></h4>

<p><a id="X86601BE281C7B8B6" name="X86601BE281C7B8B6"></a></p>

<h5>3.10-1 HeLP_MultiplicitiesOfEigenvalues</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_MultiplicitiesOfEigenvalues</code>( <var class="Arg">chi</var>, <var class="Arg">k</var>, <var class="Arg">paraugs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of multiplicities of eigenvalues</p>

<p>The returned list contains at the <span class="SimpleMath">l</span>-th spot the multiplicity of <code class="keyw">E(k)^(l-1)</code> as eigenvalue of a unit <span class="SimpleMath">u</span> of order <var class="Arg">k</var> under the representation corresponding to <var class="Arg">chi</var> having the partial augmentations <var class="Arg">paraugs</var> for the elements <span class="SimpleMath">u^d</span> for divisors <span class="SimpleMath">d</span> different from <var class="Arg">k</var>.</p>

<p><a id="X7C4C37B681A5BC7D" name="X7C4C37B681A5BC7D"></a></p>

<h5>3.10-2 HeLP_CharacterValue</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_CharacterValue</code>( <var class="Arg">chi</var>, <var class="Arg">k</var>, <var class="Arg">paraug</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the character value <span class="SimpleMath">chi(u)</span></p>

<p>The function returns the character value <span class="SimpleMath">chi(u)</span> of an element <span class="SimpleMath">u</span> of order <span class="Math">k</span> having the partial augmentations <var class="Arg">paraug</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A6");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_WithGivenOrder(C, 6);                               </span>
#I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
[ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi := Irr(C)[2];;   # a character of degree 5</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_MultiplicitiesOfEigenvalues(chi, 6, HeLP_sol[6][2]);</span>
[ 1, 0, 1, 2, 1, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_CharacterValue(chi, 6, HeLP_sol[6][2][3]);          </span>
-2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_CharacterValue(chi, 6, [-2,1,2]);</span>
-2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_CharacterValue(chi, 6, [-2,2,1]);</span>
1
</pre></div>

<p>These eigenvalues were computed manually by M. Hertweck and may be found in <a href="chapBib.html#biBHerA6">[Her08c]</a>.</p>

<p><a id="X8668C68E7C07EF99" name="X8668C68E7C07EF99"></a></p>

<h4>3.11 <span class="Heading">Check for triviality modulo normal subgroup</span></h4>

<p><a id="X819973897A847FFE" name="X819973897A847FFE"></a></p>

<h5>3.11-1 HeLP_IsOneModuloN</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_IsOneModuloN</code>( <var class="Arg">UCT</var>, <var class="Arg">k</var>, <var class="Arg">pa</var>, <var class="Arg">G</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>This function checks, if the image of a unit in <span class="Math">\mathrm{V}(\mathbb{Z}G)</span> given by the partial augmentations of itself (not its powers) is trivial modulo a normal subgroup <span class="Math">N</span>, i.e. if it maps to the identity under the natural homomorphism <span class="Math">\mathbb{Z}G \rightarrow \mathbb{Z}(G/N)</span>. The input is a character table, the order of the unit, its partial augmentations, the group and the normal subgroup.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup(144,117);</span>
&lt;pc group of size 144 with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable(G);</span>
CharacterTable( &lt;pc group of size 144 with 6 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := PCore(G, 3);</span>
Group([ f5, f6 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(N);</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_IsOneModuloN(C, 3, [1,0], G, N);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);</span>
true
</pre></div>

<p>The fact that the unit of order 3 lies in the kernel of the map modulo <span class="Math">N</span> explains why <code class="keyw">HeLP_ZC</code> produces a result different from the one recorded in <a href="chapBib.html#biBBaHeKoMaSi">[BHK+18]</a>. Namely, the unit of order 6 described there has non-vanishing partial augmentations at classes of order 6 with non-conjugate 3-parts, which contradicts the p-adic criterion of Hertweck <a href="chapBib.html#biBMargolisHertweck">[Mar17]</a>, as the 3-part of the unit is trivial modulo the 3-core of the group.</p>

<p><a id="X87E2729184EB30B3" name="X87E2729184EB30B3"></a></p>

<h5>3.11-2 HeLP_ForgetUnderlyingGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_ForgetUnderlyingGroup</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: Same character table as <code class="keyw">C</code> but without underlying group</p>

<p>Continuing the previous example we see that the normal subgroup structure of the group is needed here to get a positive solution for (ZC).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CCop := HeLP_ForgetUnderlyingGroup(C);</span>
CharacterTable( "CT4" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(CCop);</span>
#I  (ZC) can't be solved, using the given data, for the orders: [ 6 ].
false
</pre></div>

<p><a id="X87C19C44801003CD" name="X87C19C44801003CD"></a></p>

<h4>3.12 <span class="Heading">Check Kimmerle Problem for single units</span></h4>

<p><a id="X7E8B60D97999264E" name="X7E8B60D97999264E"></a></p>

<h5>3.12-1 HeLP_UnitSatisfiesKP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_UnitSatisfiesKP</code>( <var class="Arg">UCT</var>, <var class="Arg">k</var>, <var class="Arg">pa</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>Decides if a unit described by the partial augmentations of its powers satisfies the Kimmerle Problem. Input is Ordinary character table, order of the unit and the partial augmentations.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CharacterTable("A7");</span>
CharacterTable( "A7" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_ZC(C);</span>
#I  (ZC) can't be solved, using the given data, for the orders: [ 4, 6 ].
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_sol[4];</span>
[ [ [ 1 ], [ 0, 1 ] ], [ [ 1 ], [ 2, -1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_UnitSatisfiesKP(C, 4, HeLP_sol[4][1]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeLP_UnitSatisfiesKP(C, 4, HeLP_sol[4][2]);</span>
false
</pre></div>

<p><a id="X828D02D784AF3DFF" name="X828D02D784AF3DFF"></a></p>

<h4>3.13 <span class="Heading">Check whether Zassenhaus Conjecture is known from theoretical results</span></h4>

<p><a id="X80E52D94801193C4" name="X80E52D94801193C4"></a></p>

<h5>3.13-1 HeLP_IsZCKnown</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeLP_IsZCKnown</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if (ZC) can be derived from theoretical results, <code class="keyw">false</code> otherwise</p>

<p>For the given group <var class="Arg">G</var> this function applies five checks, namely it checks</p>


<ul>
<li><p>if <span class="Math">G</span> is nilpotent</p>

</li>
<li><p>if <span class="Math">G</span> has a normal Sylow subgroup with abelian complement,</p>

</li>
<li><p>if <span class="Math">G</span> is cyclic-by-abelian</p>

</li>
<li><p>if it is of the form <span class="Math">X \rtimes A</span>, where <span class="Math">X</span> and <span class="Math">A</span> are abelian and <span class="Math">A</span> is of prime order <span class="Math">p</span> such that <span class="Math">p</span> is smaller then any prime divisor of the order of <span class="Math">X</span></p>

</li>
<li><p>or if the order of <span class="Math">G</span> is smaller than <span class="Math">144</span>.</p>

</li>
</ul>
<p>In all these cases the Zassenhaus Conjecture is known. See <a href="chap5.html#X79BE759E7F35150E"><span class="RefLink">5.6</span></a> for references. This function is designed for solvable groups.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
